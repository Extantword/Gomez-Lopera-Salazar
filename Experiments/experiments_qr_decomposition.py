# -*- coding: utf-8 -*-
"""Experiments_QR_Decomposition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FlQsPD2T1-8m3JBKc9wlCaegS3BhqJPi
"""

import numpy as np

def householder_qr(A):
    """"

    Parametros
    A: Matriz a descomponer

    Returna:
    tupla: (Q, R) donde Q es matriz ortogonal y R es matriz triangular superior
    """

    A = np.array(A, dtype=float)
    m, n = A.shape
    Q = np.eye(m)
    R = A.copy()

    # Itera cada columna
    for j in range(min(m-1, n)):
        # Extraemos la columna en la que estamos trbajando
        x = R[j:, j]

        # Calculamos el vector de householder
        e1 = np.zeros_like(x)
        e1[0] = 1

        alpha = -np.sign(x[0]) * np.linalg.norm(x) # Multiplicamos por el signo para estabilidad
                                                   # numérica
        u = x - alpha * e1
        v = u / np.linalg.norm(u)
        H = np.eye(m)
        H[j:, j:] -= 2.0 * np.outer(v, v)
        R = H @ R
        Q = Q @ H.T # Vamos acumulando Q

    # Ponemos ceros en la triangular inferior para asegurar que es triangular superior
    for i in range(m):
        for j in range(i):
            if j < n:
                R[i, j] = 0.0

    return Q, R

def qr_eigenvalue_algorithm(A, max_iter=1000, tolerance=1e-10):
    
    """
    Computa autovalores usando el algoritmo QR
    
    Parameters:
    A (list): Matriz a la que se hallarán los autovalores
    max_iter (int): Número máximo de iteraciones
    tolerance (float): Tolerancia de la convergencia
    
    Returna:
    np.array: eigenvalues
    """
    
    A = np.array(A, dtype=float)
    n = A.shape[0]
    V = np.eye(n)
    H = A.copy()
    
    for _ in range(max_iter):
        
        Q, R = householder_qr(H)
        H = R @ Q
        V = V @ Q
        
        off_diag_norm = np.sum(np.abs(np.tril(H, -1))) #Calcula norma de diagonal debajo de la diagonal principal.
        
        if off_diag_norm < tolerance:
            break
    
    eigenvalues = np.diag(H)
    
    return eigenvalues

A = np.array([[1, 0, 0, 0],
              [3, 2, 0, 0],
              [1, 1, 4, 0],
              [1, 2, 1, 7]]) #Defina su matriz

result = qr_eigenvalue_algorithm(A)

print(result)